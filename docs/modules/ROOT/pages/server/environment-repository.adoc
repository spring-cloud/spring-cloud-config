[[environment-repository]]
= Environment Repository

Where should you store the configuration data for the Config Server?
The strategy that governs this behaviour is the `EnvironmentRepository`, serving `Environment` objects.
This `Environment` is a shallow copy of the domain from the Spring `Environment` (including `propertySources` as the main feature).
The `Environment` resources are parametrized by three variables:


* `\{application}`, which maps to `spring.application.name` on the client side.
* `\{profile}`, which maps to `spring.profiles.active` on the client (comma-separated list).
* `\{label}`, which is a server side feature labelling a "versioned" set of config files.

Repository implementations generally behave like a Spring Boot application, loading configuration files from a `spring.config.name` equal to the `\{application}` parameter, and `spring.profiles.active` equal to the `\{profiles}` parameter.
Precedence rules for profiles are also the same as in a regular Spring Boot application: Active profiles take precedence over defaults, and, if there are multiple profiles, the last one wins (similar to adding entries to a `Map`).

The following sample client application has this bootstrap configuration:

[source,yaml]
----
spring:
  application:
    name: foo
  profiles:
    active: dev,mysql
----

(As usual with a Spring Boot application, these properties could also be set by environment variables or command line arguments).

If the repository is file-based, the server creates an
`Environment` from `application.yml` (shared between all clients) and
`foo.yml` (with `foo.yml` taking precedence).
If the YAML files have documents inside them that point to Spring profiles, those are applied with higher precedence (in order of the profiles listed).
If there are profile-specific YAML (or properties) files, these are also applied with higher precedence than the defaults.
Higher precedence translates to a `PropertySource` listed earlier in the `Environment`.
(These same rules apply in a standalone Spring Boot application.)

You can set `spring.cloud.config.server.accept-empty` to `false` so that Server would return a HTTP 404 status, if the application is not found.  By default, this flag is set to `true`.

NOTE:  You cannot place `spring.main.*` properties in a remote `EnvironmentRepository`.  These properties are used as part of the application initialization.

== File Content Resolution

The Config Server can resolve the content of local files and serve them as Base64 encoded values.
This is particularly useful for serving binary files, such as SSL keystores or certificates, within configuration properties.

To enable this feature, you must set the following property (it is disabled by default for security reasons):

[source,yaml]
----
spring:
  cloud:
    config:
      server:
        file-resolving:
          enabled: true
----

WARNING: Enabling this feature allows the Config Server to read files from the local file system where the server is running. Ensure that the process has appropriate file system permissions and is running in a secure environment.

When this feature is enabled, you can use the `{file}` prefix in your configuration values followed by the path to the file.
The Config Server will read the file, encode its content to a Base64 string, and replace the property value.

For example, in your backing repository (e.g., Git or Native), you can define a property like this:

[source,yaml]
----
server:
  ssl:
    key-store: {file}/etc/certs/keystore.jks
    key-password: my-secret-password
----

In this example, the Config Server reads `/etc/certs/keystore.jks`, encodes it, and returns the Base64 string as the value of `server.ssl.key-store`.
